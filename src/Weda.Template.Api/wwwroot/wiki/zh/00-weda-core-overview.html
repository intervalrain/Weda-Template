<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="WikiGenerator">
    <link rel="stylesheet" href="../wiki.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <article class="markdown-body">
    <h1 id="weda.core">Weda.Core 概觀</h1>
<blockquote>
<p>用於建構 Clean Architecture 應用程式的共用基礎設施函式庫，支援 DDD、CQRS 與 Event-Driven Messaging</p>
</blockquote>
<h2 id="weda.core-1">什麼是 Weda.Core？</h2>
<p>Weda.Core 是一個基礎函式庫，提供建構遵循 Clean Architecture 與 Domain-Driven Design 原則的應用程式所需的所有 Base Class、抽象與基礎設施。它消除了重複的樣板程式碼，並確保專案間的一致性。</p>
<pre><code>Weda.Core/
├── Domain/              # DDD Base Class (Entity, AggregateRoot 等)
├── Application/         # CQRS Behavior、Security、Interface
├── Infrastructure/      # Persistence、NATS Messaging、Middleware
├── Api/                 # REST Controller Base、Swagger 設定
└── WedaCoreModule.cs    # Service 註冊與 Middleware 設定
</code></pre>
<hr />
<h2 id="section">架構概觀</h2>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│                         Your Application                             │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌───────────────┐  ┌───────────┐  │
│  │   Domain    │  │ Application │  │ Infrastructure│  │    Api    │  │
│  │   Layer     │  │   Layer     │  │     Layer     │  │   Layer   │  │
│  └──────┬──────┘  └──────┬──────┘  └───────┬───────┘  └─────┬─────┘  │
│         │                │                 │                │        │
├─────────┴────────────────┴─────────────────┴────────────────┴────────┤
│                           Weda.Core                                  │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐  ┌───────────┐  │
│  │   Entity     │  │  Behaviors   │  │  DbContext  │  │    Api    │  │
│  │ AggregateRoot│  │ Validation   │  │  Repository │  │ Controller│  │
│  │ IDomainEvent │  │ Authorization│  │    NATS     │  │  Swagger  │  │
│  │ IRepository  │  │  Security    │  │ Middleware  │  │  Filters  │  │
│  └──────────────┘  └──────────────┘  └─────────────┘  └───────────┘  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="domain">1. Domain 抽象</h2>
<p>Weda.Core 提供 Domain-Driven Design 的基礎：</p>
<h3 id="entity">Entity<TId></h3>
<p>所有 Domain Entity 的 Base Class，具備基於 Identity 的相等性比較。</p>
<pre><code class="language-csharp">public abstract class Entity&lt;TId&gt; : IEquatable&lt;Entity&lt;TId&gt;&gt;
    where TId : notnull
{
    public TId Id { get; protected init; }

    public override bool Equals(object? obj) =&gt;
        obj is Entity&lt;TId&gt; entity &amp;&amp; Id.Equals(entity.Id);

    public override int GetHashCode() =&gt; Id.GetHashCode();
}
</code></pre>
<h3 id="aggregateroot">AggregateRoot<TId></h3>
<p>作為 Aggregate 邊界的 Entity，支援 Domain Event。</p>
<pre><code class="language-csharp">public abstract class AggregateRoot&lt;TId&gt; : Entity&lt;TId&gt;, IAggregateRoot
    where TId : notnull
{
    private readonly List&lt;IDomainEvent&gt; _domainEvents = [];

    public List&lt;IDomainEvent&gt; PopDomainEvents()
    {
        var copy = _domainEvents.ToList();
        _domainEvents.Clear();
        return copy;
    }

    protected void RaiseDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }
}
</code></pre>
<h3 id="irepositoryt-tid">IRepository&lt;T, TId&gt;</h3>
<p>資料存取抽象的 Generic Repository Interface。</p>
<pre><code class="language-csharp">public interface IRepository&lt;T, TId&gt;
    where T : Entity&lt;TId&gt;
    where TId : notnull
{
    Task&lt;T?&gt; GetByIdAsync(TId id, CancellationToken cancellationToken = default);
    Task&lt;List&lt;T&gt;&gt; GetAllAsync(CancellationToken cancellationToken = default);
    Task AddAsync(T entity, CancellationToken cancellationToken = default);
    Task UpdateAsync(T entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(T entity, CancellationToken cancellationToken = default);
}
</code></pre>
<h3 id="idomainevent">IDomainEvent</h3>
<p>Domain Event 的 Marker Interface，繼承 Mediator 的 <code>INotification</code>。</p>
<pre><code class="language-csharp">public interface IDomainEvent : INotification { }
</code></pre>
<hr />
<h2 id="application-layer">2. Application Layer 元件</h2>
<h3 id="pipeline-behavior">Pipeline Behavior</h3>
<p>Weda.Core 提供 Mediator Pipeline Behavior 處理 Cross-Cutting Concern：</p>
<p><strong>ValidationBehavior</strong></p>
<ul>
<li>在 Handler 執行前攔截所有 Request</li>
<li>使用 FluentValidation 驗證 Request 物件</li>
<li>驗證失敗時回傳包含驗證錯誤的 <code>ErrorOr</code></li>
</ul>
<p><strong>AuthorizationBehavior</strong></p>
<ul>
<li>攔截 <code>IAuthorizeableRequest&lt;T&gt;</code> 實作</li>
<li>讀取 <code>[Authorize]</code> Attribute 取得所需的 Role、Permission、Policy</li>
<li>委派給 <code>IAuthorizationService</code> 進行授權檢查</li>
</ul>
<h3 id="security">Security 基礎設施</h3>
<pre><code class="language-csharp">// 宣告式授權的 Attribute
[Authorize(Roles = &quot;Admin&quot;, Permissions = &quot;employees:write&quot;)]
public record CreateEmployeeCommand(...) : IAuthorizeableRequest&lt;ErrorOr&lt;EmployeeDto&gt;&gt;;

// Authorization Service 的 Interface
public interface IAuthorizationService
{
    ErrorOr&lt;Success&gt; AuthorizeCurrentUser&lt;T&gt;(
        IAuthorizeableRequest&lt;T&gt; request,
        List&lt;string&gt; requiredRoles,
        List&lt;string&gt; requiredPermissions,
        List&lt;string&gt; requiredPolicies);
}

// JWT Token 產生器的 Interface
public interface IJwtTokenGenerator
{
    string GenerateToken(
        int id,
        string name,
        string email,
        List&lt;string&gt; permissions,
        List&lt;string&gt; roles);
}
</code></pre>
<h3 id="application-interface">Application Interface</h3>
<pre><code class="language-csharp">// 可測試時間操作的抽象
public interface IDateTimeProvider
{
    DateTime UtcNow { get; }
}
</code></pre>
<hr />
<h2 id="infrastructure">3. Infrastructure 元件</h2>
<h3 id="wedadbcontext">WedaDbContext</h3>
<p>具備自動 Domain Event 發布與 Eventual Consistency 支援的 Base DbContext。</p>
<pre><code class="language-csharp">public abstract class WedaDbContext : DbContext
{
    public override async Task&lt;int&gt; SaveChangesAsync(
        CancellationToken cancellationToken = default)
    {
        // 1. 從 Aggregate Root 收集 Domain Event
        var domainEvents = ChangeTracker.Entries&lt;IAggregateRoot&gt;()
            .SelectMany(e =&gt; e.Entity.PopDomainEvents())
            .ToList();

        // 2. 儲存變更至資料庫
        var result = await base.SaveChangesAsync(cancellationToken);

        // 3. 佇列或發布 Domain Event
        if (IsUserOnline)
            QueueEventsForEventualConsistency(domainEvents);
        else
            await PublishEventsImmediately(domainEvents);

        return result;
    }
}
</code></pre>
<h3 id="genericrepositoryt-tid-tdbcontext">GenericRepository&lt;T, TId, TDbContext&gt;</h3>
<p>使用 EF Core 的 Base Repository 實作。</p>
<pre><code class="language-csharp">public class GenericRepository&lt;T, TId, TDbContext&gt; : IRepository&lt;T, TId&gt;
    where T : Entity&lt;TId&gt;
    where TId : notnull
    where TDbContext : DbContext
{
    protected readonly TDbContext DbContext;
    protected readonly DbSet&lt;T&gt; DbSet;

    // 具備自動 SaveChanges 的標準 CRUD 操作
}
</code></pre>
<h3 id="eventual-consistency-middleware">Eventual Consistency Middleware</h3>
<p>確保 Domain Event 在同一個 Transaction 內發布。</p>
<pre><code>HTTP Request
     ↓
Begin Transaction
     ↓
Controller → Handler → Repository.SaveChanges()
     ↓
Domain Event 佇列於 HttpContext
     ↓
Response 送回 Client
     ↓
發布佇列中的 Domain Event
     ↓
Commit Transaction
</code></pre>
<h3 id="nats-messaging">NATS Messaging</h3>
<p>完整的 Event-Driven Messaging 基礎設施，支援多種模式：</p>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Request-Reply</td>
<td>同步 RPC 風格的通訊</td>
</tr>
<tr>
<td>Core Pub-Sub</td>
<td>Fire-and-Forget 訊息傳遞</td>
</tr>
<tr>
<td>JetStream Consume</td>
<td>持久化、保證遞送的持續消費</td>
</tr>
<tr>
<td>JetStream Fetch</td>
<td>批次訊息處理</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="api">4. API 元件</h2>
<h3 id="apicontroller">ApiController</h3>
<p>具備自動錯誤對應至 ProblemDetails 的 Base Controller。</p>
<pre><code class="language-csharp">[ApiController]
[Authorize]
[Route(&quot;api/v{version:apiVersion}/[controller]&quot;)]
public class ApiController : ControllerBase
{
    protected ActionResult Problem(List&lt;Error&gt; errors)
    {
        // 將 ErrorOr Error 對應至適當的 HTTP Status Code
        // - Validation → 400 Bad Request
        // - NotFound → 404 Not Found
        // - Conflict → 409 Conflict
        // - Unauthorized → 401 Unauthorized
        // - Forbidden → 403 Forbidden
    }
}
</code></pre>
<h3 id="eventcontroller">EventController</h3>
<p>NATS Event-Driven Endpoint 的 Base Class。</p>
<pre><code class="language-csharp">[Stream(&quot;employees_v1_stream&quot;)]
[Consumer(&quot;employees_v1_consumer&quot;)]
[Connection(&quot;bus&quot;)]
public abstract class EventController
{
    public IMediator Mediator { get; }
    public INatsConnectionProvider NatsProvider { get; }
    public ILogger Logger { get; }
    public string Subject { get; }
    public IReadOnlyDictionary&lt;string, string&gt; SubjectValues { get; }
}
</code></pre>
<h3 id="swagger">Swagger 整合</h3>
<ul>
<li>自動產生 OpenAPI 文件</li>
<li>透過 <code>IExamplesProvider&lt;T&gt;</code> 注入 Request/Response 範例</li>
<li>為授權 Endpoint 加入 Bearer Token Security</li>
</ul>
<hr />
<h2 id="module">5. Module 註冊</h2>
<h3 id="weda.core-2">將 Weda.Core 加入您的應用程式</h3>
<pre><code class="language-csharp">// Program.cs
using System.Reflection;
using Microsoft.OpenApi;
using Weda.Core;
using Weda.Template.Api;
using Weda.Template.Application;
using Weda.Template.Contracts;
using Weda.Template.Infrastructure;
using Weda.Template.Infrastructure.Common.Persistence;

var builder = WebApplication.CreateBuilder(args);
{
    builder.Services
        .AddApplication()
        .AddInfrastructure(builder.Configuration)
        .AddWedaCore&lt;IAssemblyMarker, IContractsMarker, IApplicationMarker&gt;(
            builder.Configuration,
            services =&gt; services.AddMediator(options =&gt;
            {
                options.ServiceLifetime = ServiceLifetime.Scoped;
                options.Assemblies = [typeof(IApplicationMarker).Assembly];
            }),
            options =&gt;
            {
                options.XmlCommentAssemblies = [Assembly.GetExecutingAssembly()];
                options.OpenApiInfo = new OpenApiInfo
                {
                    Title = &quot;Weda API&quot;,
                    Version = &quot;v1&quot;,
                };
            });
}

var app = builder.Build();
{
    app.UseWedaCore&lt;AppDbContext&gt;(options =&gt;
    {
        options.EnsureDatabaseCreated = false;
        options.SwaggerEndpointUrl = &quot;/swagger/v1/swagger.json&quot;;
        options.SwaggerEndpointName = &quot;Weda API V1&quot;;
        options.RoutePrefix = &quot;swagger&quot;;
    });

    app.Run();
}
</code></pre>
<h3 id="addwedacore">AddWedaCore 參數</h3>
<table>
<thead>
<tr>
<th>參數</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TApiMarker</code></td>
<td>API Assembly Marker，用於掃描 EventController</td>
</tr>
<tr>
<td><code>TContractsMarker</code></td>
<td>Contracts Assembly Marker，用於 Swagger 範例</td>
</tr>
<tr>
<td><code>TApplicationMarker</code></td>
<td>Application Assembly Marker，用於 Validator</td>
</tr>
<tr>
<td><code>configuration</code></td>
<td>IConfiguration，用於讀取設定</td>
</tr>
<tr>
<td><code>mediatorAction</code></td>
<td>設定 Mediator 選項的 Callback</td>
</tr>
<tr>
<td><code>optionsAction</code></td>
<td>設定 WedaCoreOptions 的 Callback</td>
</tr>
</tbody>
</table>
<h3 id="wedacoreoptions-addwedacore">WedaCoreOptions (AddWedaCore)</h3>
<table>
<thead>
<tr>
<th>選項</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>XmlCommentAssemblies</code></td>
<td>包含 XML 註解的 Assembly，供 Swagger 使用</td>
</tr>
<tr>
<td><code>OpenApiInfo</code></td>
<td>OpenAPI 文件資訊（標題、版本）</td>
</tr>
</tbody>
</table>
<h3 id="wedacoremiddlewareoptions-usewedacore">WedaCoreMiddlewareOptions (UseWedaCore)</h3>
<table>
<thead>
<tr>
<th>選項</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EnsureDatabaseCreated</code></td>
<td>啟動時自動建立資料庫</td>
</tr>
<tr>
<td><code>SwaggerEndpointUrl</code></td>
<td>Swagger JSON Endpoint URL</td>
</tr>
<tr>
<td><code>SwaggerEndpointName</code></td>
<td>Swagger Endpoint 顯示名稱</td>
</tr>
<tr>
<td><code>RoutePrefix</code></td>
<td>Swagger UI Route Prefix</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="section-1">6. 關鍵相依套件</h2>
<p>Weda.Core 整合以下函式庫（皆為 MIT License）：</p>
<table>
<thead>
<tr>
<th>函式庫</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ErrorOr</strong></td>
<td>Functional Error Handling</td>
</tr>
<tr>
<td><strong>Mediator</strong></td>
<td>CQRS 與 Pipeline Behavior（基於 Source Generator，高效能）</td>
</tr>
<tr>
<td><strong>Mapperly</strong></td>
<td>物件對應，透過 Source Generator（零 Reflection）</td>
</tr>
<tr>
<td><strong>FluentValidation</strong></td>
<td>Request 驗證</td>
</tr>
<tr>
<td><strong>NATS.Net</strong></td>
<td>Messaging 與 Event Streaming</td>
</tr>
<tr>
<td><strong>Entity Framework Core</strong></td>
<td>資料庫持久化</td>
</tr>
<tr>
<td><strong>Asp.Versioning</strong></td>
<td>API Versioning</td>
</tr>
<tr>
<td><strong>Swashbuckle</strong></td>
<td>OpenAPI/Swagger 文件</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="section-2">7. 實作的設計模式</h2>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>實作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain-Driven Design</td>
<td>Entity、AggregateRoot、Domain Event、Repository</td>
</tr>
<tr>
<td>CQRS</td>
<td>透過 Mediator 分離 Command/Query</td>
</tr>
<tr>
<td>Repository</td>
<td>Generic 與特化的 Repository 抽象</td>
</tr>
<tr>
<td>Eventual Consistency</td>
<td>基於 Middleware 的 Domain Event 發布</td>
</tr>
<tr>
<td>Pipeline</td>
<td>Validation 與 Authorization Behavior</td>
</tr>
<tr>
<td>Factory Method</td>
<td>使用 ErrorOr 的 Entity 建立</td>
</tr>
<tr>
<td>Event-Driven</td>
<td>Domain Event 與 NATS Messaging</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="section-3">相關資源</h2>
<ul>
<li><a href="01-domain-layer.md">01-domain-layer.md</a> - Domain Layer 實作指南</li>
<li><a href="02-application-layer.md">02-application-layer.md</a> - Application Layer 指南</li>
<li><a href="03-infrastructure-layer.md">03-infrastructure-layer.md</a> - Infrastructure Layer 指南</li>
<li><a href="04-api-layer.md">04-api-layer.md</a> - API Layer 指南</li>
<li><a href="GUIDE.md">GUIDE.md</a> - 學習指南總覽</li>
</ul>

    </article>
</body>
</html>