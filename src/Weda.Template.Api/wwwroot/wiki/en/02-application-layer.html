<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="WikiGenerator">
    <link rel="stylesheet" href="../wiki.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <article class="markdown-body">
    <h1 id="application-layer-implementation-guide">Application Layer Implementation Guide</h1>
<blockquote>
<p>Learn how to implement use cases with CQRS pattern and Mediator</p>
</blockquote>
<h2 id="overview">Overview</h2>
<p>The Application Layer orchestrates domain operations and implements use cases. It depends on Domain Layer but knows nothing about Infrastructure or API layers.</p>
<pre><code>src/Weda.Template.Application/
├── Common/
│   ├── Behaviors/
│   │   ├── ValidationBehavior.cs
│   │   └── AuthorizationBehavior.cs
│   └── Interfaces/
│       └── IDateTimeProvider.cs
├── Employees/
│   ├── Commands/
│   │   ├── CreateEmployee/
│   │   │   ├── CreateEmployeeCommandHandler.cs
│   │   │   └── CreateEmployeeCommandValidator.cs
│   │   ├── UpdateEmployee/
│   │   └── DeleteEmployee/
│   ├── Queries/
│   │   ├── GetEmployee/
│   │   ├── ListEmployees/
│   │   └── GetSubordinates/
│   ├── EventHandlers/
│   │   └── EmployeeCreatedEventHandler.cs
│   └── Mapping/
│       └── EmployeeMapper.cs
├── WedaTemplateApplicationModule.cs
└── IApplicationMarker.cs
</code></pre>
<hr />
<h2 id="commands-and-queries-cqrs">1. Commands and Queries (CQRS)</h2>
<h3 id="command-definition">1.1 Command Definition</h3>
<p>Commands are defined in the Contracts layer and handled in Application layer.</p>
<pre><code class="language-csharp">// In Contracts layer: Weda.Template.Contracts/Employees/Commands/
public record CreateEmployeeCommand(
    string Name,
    string Email,
    string Department,
    string Position,
    DateTime HireDate,
    int? SupervisorId = null) : IRequest&lt;ErrorOr&lt;EmployeeDto&gt;&gt;;

public record UpdateEmployeeCommand(
    int Id,
    string Name,
    string Department,
    string Position) : IRequest&lt;ErrorOr&lt;EmployeeDto&gt;&gt;;

public record DeleteEmployeeCommand(int Id) : IRequest&lt;ErrorOr&lt;Deleted&gt;&gt;;
</code></pre>
<h3 id="query-definition">1.2 Query Definition</h3>
<pre><code class="language-csharp">// In Contracts layer: Weda.Template.Contracts/Employees/Queries/
public record GetEmployeeQuery(int Id) : IRequest&lt;ErrorOr&lt;EmployeeDto&gt;&gt;;

public record ListEmployeesQuery() : IRequest&lt;ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt;;

public record GetSubordinatesQuery(
    int EmployeeId,
    bool IncludeIndirect = false) : IRequest&lt;ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt;;
</code></pre>
<h3 id="command-vs-query">Command vs Query</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Command</th>
<th>Query</th>
</tr>
</thead>
<tbody>
<tr>
<td>Purpose</td>
<td>Change state</td>
<td>Read data</td>
</tr>
<tr>
<td>Return Type</td>
<td><code>ErrorOr&lt;T&gt;</code> or <code>ErrorOr&lt;Deleted&gt;</code></td>
<td><code>ErrorOr&lt;TDto&gt;</code> or <code>ErrorOr&lt;List&lt;TDto&gt;&gt;</code></td>
</tr>
<tr>
<td>Side Effects</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Folder</td>
<td><code>Commands/{ActionName}/</code></td>
<td><code>Queries/{ActionName}/</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="command-handlers">2. Command Handlers</h2>
<h3 id="create-handler">2.1 Create Handler</h3>
<pre><code class="language-csharp">public class CreateEmployeeCommandHandler
    : IRequestHandler&lt;CreateEmployeeCommand, ErrorOr&lt;EmployeeDto&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;
    private readonly EmployeeHierarchyManager _hierarchyManager;

    public CreateEmployeeCommandHandler(
        IEmployeeRepository employeeRepository,
        EmployeeHierarchyManager hierarchyManager)
    {
        _employeeRepository = employeeRepository;
        _hierarchyManager = hierarchyManager;
    }

    public async Task&lt;ErrorOr&lt;EmployeeDto&gt;&gt; Handle(
        CreateEmployeeCommand request,
        CancellationToken cancellationToken)
    {
        // 1. Create Value Objects
        var nameResult = EmployeeName.Create(request.Name);
        if (nameResult.IsError)
            return nameResult.Errors;

        var emailResult = Email.Create(request.Email);
        if (emailResult.IsError)
            return emailResult.Errors;

        var departmentResult = Department.Create(request.Department);
        if (departmentResult.IsError)
            return departmentResult.Errors;

        // 2. Check for duplicate email
        if (await _employeeRepository.ExistsWithEmailAsync(
            emailResult.Value, cancellationToken))
        {
            return EmployeeErrors.DuplicateEmail;
        }

        // 3. Create Aggregate
        var employeeResult = Employee.Create(
            nameResult.Value,
            emailResult.Value,
            departmentResult.Value,
            request.Position,
            request.HireDate,
            request.SupervisorId);

        if (employeeResult.IsError)
            return employeeResult.Errors;

        var employee = employeeResult.Value;

        // 4. Validate supervisor if provided
        if (request.SupervisorId.HasValue)
        {
            var assignResult = await _hierarchyManager.AssignSupervisorAsync(
                employee,
                request.SupervisorId.Value,
                cancellationToken);

            if (assignResult.IsError)
                return assignResult.Errors;
        }

        // 5. Persist
        await _employeeRepository.AddAsync(employee, cancellationToken);

        // 6. Map and return
        return EmployeeMapper.ToDto(employee);
    }
}
</code></pre>
<h3 id="update-handler">2.2 Update Handler</h3>
<pre><code class="language-csharp">public class UpdateEmployeeCommandHandler
    : IRequestHandler&lt;UpdateEmployeeCommand, ErrorOr&lt;EmployeeDto&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;

    public UpdateEmployeeCommandHandler(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = employeeRepository;
    }

    public async Task&lt;ErrorOr&lt;EmployeeDto&gt;&gt; Handle(
        UpdateEmployeeCommand request,
        CancellationToken cancellationToken)
    {
        // 1. Retrieve entity
        var employee = await _employeeRepository
            .GetByIdAsync(request.Id, cancellationToken);

        if (employee is null)
            return EmployeeErrors.NotFound;

        // 2. Create Value Objects
        var nameResult = EmployeeName.Create(request.Name);
        if (nameResult.IsError)
            return nameResult.Errors;

        var departmentResult = Department.Create(request.Department);
        if (departmentResult.IsError)
            return departmentResult.Errors;

        // 3. Update via domain method
        var updateResult = employee.UpdateInfo(
            nameResult.Value,
            departmentResult.Value,
            request.Position);

        if (updateResult.IsError)
            return updateResult.Errors;

        // 4. Persist
        await _employeeRepository.UpdateAsync(employee, cancellationToken);

        // 5. Return mapped DTO
        return EmployeeMapper.ToDto(employee);
    }
}
</code></pre>
<h3 id="delete-handler">2.3 Delete Handler</h3>
<pre><code class="language-csharp">public class DeleteEmployeeCommandHandler
    : IRequestHandler&lt;DeleteEmployeeCommand, ErrorOr&lt;Deleted&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;

    public DeleteEmployeeCommandHandler(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = employeeRepository;
    }

    public async Task&lt;ErrorOr&lt;Deleted&gt;&gt; Handle(
        DeleteEmployeeCommand request,
        CancellationToken cancellationToken)
    {
        var employee = await _employeeRepository
            .GetByIdAsync(request.Id, cancellationToken);

        if (employee is null)
            return EmployeeErrors.NotFound;

        // Check business rules before delete
        var subordinates = await _employeeRepository
            .GetBySupervisorIdAsync(request.Id, cancellationToken);

        if (subordinates.Count &gt; 0)
            return EmployeeErrors.HasSubordinates;

        await _employeeRepository.DeleteAsync(employee, cancellationToken);

        return Result.Deleted;
    }
}
</code></pre>
<h3 id="handler-pattern">Handler Pattern</h3>
<pre><code>┌────────────────────────────────────────────────────────────────────┐
│                        Command Handler Flow                        │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. Receive Command                                                │
│         ↓                                                          │
│  2. Create/Validate Value Objects                                  │
│         ↓                                                          │
│  3. Retrieve Entity (if update/delete)                             │
│         ↓                                                          │
│  4. Execute Domain Logic                                           │
│         ↓                                                          │
│  5. Use Domain Service (if needed)                                 │
│         ↓                                                          │
│  6. Persist via Repository                                         │
│         ↓                                                          │
│  7. Map to DTO and Return                                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="query-handlers">3. Query Handlers</h2>
<h3 id="get-single-entity">3.1 Get Single Entity</h3>
<pre><code class="language-csharp">public class GetEmployeeQueryHandler
    : IRequestHandler&lt;GetEmployeeQuery, ErrorOr&lt;EmployeeDto&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;

    public GetEmployeeQueryHandler(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = employeeRepository;
    }

    public async Task&lt;ErrorOr&lt;EmployeeDto&gt;&gt; Handle(
        GetEmployeeQuery request,
        CancellationToken cancellationToken)
    {
        var employee = await _employeeRepository
            .GetByIdAsync(request.Id, cancellationToken);

        if (employee is null)
            return EmployeeErrors.NotFound;

        return EmployeeMapper.ToDto(employee);
    }
}
</code></pre>
<h3 id="list-entities">3.2 List Entities</h3>
<pre><code class="language-csharp">public class ListEmployeesQueryHandler
    : IRequestHandler&lt;ListEmployeesQuery, ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;

    public ListEmployeesQueryHandler(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = employeeRepository;
    }

    public async Task&lt;ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt; Handle(
        ListEmployeesQuery request,
        CancellationToken cancellationToken)
    {
        var employees = await _employeeRepository
            .GetAllAsync(cancellationToken);

        return employees.Select(EmployeeMapper.ToDto).ToList();
    }
}
</code></pre>
<h3 id="complex-query-with-domain-service">3.3 Complex Query with Domain Service</h3>
<pre><code class="language-csharp">public class GetSubordinatesQueryHandler
    : IRequestHandler&lt;GetSubordinatesQuery, ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt;
{
    private readonly IEmployeeRepository _employeeRepository;
    private readonly EmployeeHierarchyManager _hierarchyManager;

    public GetSubordinatesQueryHandler(
        IEmployeeRepository employeeRepository,
        EmployeeHierarchyManager hierarchyManager)
    {
        _employeeRepository = employeeRepository;
        _hierarchyManager = hierarchyManager;
    }

    public async Task&lt;ErrorOr&lt;List&lt;EmployeeDto&gt;&gt;&gt; Handle(
        GetSubordinatesQuery request,
        CancellationToken cancellationToken)
    {
        var employee = await _employeeRepository
            .GetByIdAsync(request.EmployeeId, cancellationToken);

        if (employee is null)
            return EmployeeErrors.NotFound;

        var subordinates = request.IncludeIndirect
            ? await _hierarchyManager.GetAllSubordinatesAsync(
                request.EmployeeId, cancellationToken)
            : await _employeeRepository.GetBySupervisorIdAsync(
                request.EmployeeId, cancellationToken);

        return subordinates.Select(EmployeeMapper.ToDto).ToList();
    }
}
</code></pre>
<hr />
<h2 id="validators-fluentvalidation">4. Validators (FluentValidation)</h2>
<h3 id="command-validator">4.1 Command Validator</h3>
<pre><code class="language-csharp">public class CreateEmployeeCommandValidator
    : AbstractValidator&lt;CreateEmployeeCommand&gt;
{
    public CreateEmployeeCommandValidator()
    {
        RuleFor(x =&gt; x.Name)
            .NotEmpty()
            .WithMessage(&quot;Name is required&quot;)
            .MaximumLength(EmployeeName.MaxLength)
            .WithMessage($&quot;Name cannot exceed {EmployeeName.MaxLength} characters&quot;);

        RuleFor(x =&gt; x.Email)
            .NotEmpty()
            .WithMessage(&quot;Email is required&quot;)
            .MaximumLength(Email.MaxLength)
            .WithMessage($&quot;Email cannot exceed {Email.MaxLength} characters&quot;)
            .EmailAddress()
            .WithMessage(&quot;Invalid email format&quot;);

        RuleFor(x =&gt; x.Department)
            .NotEmpty()
            .WithMessage(&quot;Department is required&quot;)
            .MaximumLength(Department.MaxLength)
            .WithMessage($&quot;Department cannot exceed {Department.MaxLength} characters&quot;);

        RuleFor(x =&gt; x.Position)
            .NotEmpty()
            .WithMessage(&quot;Position is required&quot;)
            .MaximumLength(100)
            .WithMessage(&quot;Position cannot exceed 100 characters&quot;);

        RuleFor(x =&gt; x.HireDate)
            .NotEmpty()
            .WithMessage(&quot;Hire date is required&quot;)
            .LessThanOrEqualTo(DateTime.UtcNow)
            .WithMessage(&quot;Hire date cannot be in the future&quot;);
    }
}
</code></pre>
<h3 id="validation-pipeline-behavior">4.2 Validation Pipeline Behavior</h3>
<p>The <code>ValidationBehavior</code> from Weda.Core automatically intercepts requests:</p>
<pre><code class="language-csharp">public class ValidationBehavior&lt;TRequest, TResponse&gt;
    : IPipelineBehavior&lt;TRequest, TResponse&gt;
    where TRequest : IRequest&lt;TResponse&gt;
    where TResponse : IErrorOr
{
    private readonly IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; _validators;

    public ValidationBehavior(IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; validators)
    {
        _validators = validators;
    }

    public async Task&lt;TResponse&gt; Handle(
        TRequest request,
        RequestHandlerDelegate&lt;TResponse&gt; next,
        CancellationToken cancellationToken)
    {
        if (!_validators.Any())
            return await next();

        var context = new ValidationContext&lt;TRequest&gt;(request);

        var validationResults = await Task.WhenAll(
            _validators.Select(v =&gt; v.ValidateAsync(context, cancellationToken)));

        var errors = validationResults
            .SelectMany(r =&gt; r.Errors)
            .Where(f =&gt; f is not null)
            .Select(f =&gt; Error.Validation(f.PropertyName, f.ErrorMessage))
            .ToList();

        if (errors.Count &gt; 0)
            return (dynamic)errors;

        return await next();
    }
}
</code></pre>
<hr />
<h2 id="event-handlers">5. Event Handlers</h2>
<h3 id="domain-event-handler">5.1 Domain Event Handler</h3>
<pre><code class="language-csharp">public class EmployeeCreatedEventHandler
    : INotificationHandler&lt;EmployeeCreatedEvent&gt;
{
    private readonly ILogger&lt;EmployeeCreatedEventHandler&gt; _logger;
    private readonly INatsConnectionProvider _natsProvider;

    public EmployeeCreatedEventHandler(
        ILogger&lt;EmployeeCreatedEventHandler&gt; logger,
        INatsConnectionProvider natsProvider)
    {
        _logger = logger;
        _natsProvider = natsProvider;
    }

    public async Task Handle(
        EmployeeCreatedEvent notification,
        CancellationToken cancellationToken)
    {
        var employee = notification.Employee;

        _logger.LogInformation(
            &quot;Employee created: {Id} - {Name}&quot;,
            employee.Id,
            employee.Name);

        // Publish to NATS
        var natsEvent = new CreateEmployeeNatsEvent(
            employee.Id,
            employee.Name,
            employee.Email,
            employee.Department,
            employee.CreatedAt);

        await _natsProvider.PublishAsync(
            EmployeeNatsSubjects.Created,
            natsEvent,
            cancellationToken);
    }
}
</code></pre>
<h3 id="event-handler-best-practices">Event Handler Best Practices</h3>
<table>
<thead>
<tr>
<th>Practice</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Idempotency</td>
<td>Handler should be safe to run multiple times</td>
</tr>
<tr>
<td>Async Operations</td>
<td>Use for external integrations (NATS, email, etc.)</td>
</tr>
<tr>
<td>Error Handling</td>
<td>Log errors, consider retry mechanisms</td>
</tr>
<tr>
<td>Single Responsibility</td>
<td>One handler per side effect</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="mappers">6. Mappers</h2>
<h3 id="mapperly-source-generator">6.1 Mapperly Source Generator</h3>
<pre><code class="language-csharp">[Mapper]
public static partial class EmployeeMapper
{
    public static partial EmployeeDto ToDto(Employee employee);

    // Custom mapping for Value Objects
    private static string MapName(EmployeeName name) =&gt; name.Value;
    private static string MapEmail(Email email) =&gt; email.Value;
    private static string MapDepartment(Department dept) =&gt; dept.Value;
    private static string MapStatus(EmployeeStatus status) =&gt; status.ToString();
}
</code></pre>
<h3 id="dto-definition">6.2 DTO Definition</h3>
<pre><code class="language-csharp">// In Contracts layer
public record EmployeeDto(
    int Id,
    string Name,
    string Email,
    string Department,
    string Position,
    DateTime HireDate,
    string Status,
    int? SupervisorId,
    DateTime CreatedAt,
    DateTime? UpdatedAt);
</code></pre>
<hr />
<h2 id="module-registration">7. Module Registration</h2>
<h3 id="application-module">7.1 Application Module</h3>
<pre><code class="language-csharp">public static class WedaTemplateApplicationModule
{
    public static IServiceCollection AddApplication(
        this IServiceCollection services)
    {
        // Register application-specific services here
        // Mediator and validators are registered in Weda.Core

        return services;
    }
}
</code></pre>
<h3 id="assembly-marker">7.2 Assembly Marker</h3>
<pre><code class="language-csharp">// Used for assembly scanning
public interface IApplicationMarker { }
</code></pre>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<h3 id="file-naming-conventions">File Naming Conventions</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Pattern</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td><code>{Action}{Aggregate}Command.cs</code></td>
<td><code>CreateEmployeeCommand.cs</code></td>
</tr>
<tr>
<td>Command Handler</td>
<td><code>{Action}{Aggregate}CommandHandler.cs</code></td>
<td><code>CreateEmployeeCommandHandler.cs</code></td>
</tr>
<tr>
<td>Validator</td>
<td><code>{Command}Validator.cs</code></td>
<td><code>CreateEmployeeCommandValidator.cs</code></td>
</tr>
<tr>
<td>Query</td>
<td><code>{Action}{Aggregate}Query.cs</code></td>
<td><code>GetEmployeeQuery.cs</code></td>
</tr>
<tr>
<td>Query Handler</td>
<td><code>{Action}{Aggregate}QueryHandler.cs</code></td>
<td><code>GetEmployeeQueryHandler.cs</code></td>
</tr>
<tr>
<td>Event Handler</td>
<td><code>{Event}Handler.cs</code></td>
<td><code>EmployeeCreatedEventHandler.cs</code></td>
</tr>
<tr>
<td>Mapper</td>
<td><code>{Aggregate}Mapper.cs</code></td>
<td><code>EmployeeMapper.cs</code></td>
</tr>
</tbody>
</table>
<h3 id="folder-structure">Folder Structure</h3>
<pre><code>Application/
└── {AggregateName}/
    ├── Commands/
    │   └── {ActionName}/
    │       ├── {Action}CommandHandler.cs
    │       └── {Action}CommandValidator.cs
    ├── Queries/
    │   └── {ActionName}/
    │       └── {Action}QueryHandler.cs
    ├── EventHandlers/
    │   └── {Event}Handler.cs
    └── Mapping/
        └── {Aggregate}Mapper.cs
</code></pre>
<hr />
<h2 id="related-resources">Related Resources</h2>
<ul>
<li><a href="GUIDE.md">GUIDE.md</a> - Learning Guide Overview</li>
<li><a href="01-domain-layer.md">01-domain-layer.md</a> - Domain Layer Guide</li>
<li><a href="03-infrastructure-layer.md">03-infrastructure-layer.md</a> - Infrastructure Layer Guide</li>
<li><a href="https://github.com/martinothamar/Mediator">Mediator Documentation</a></li>
<li><a href="https://docs.fluentvalidation.net/">FluentValidation Documentation</a></li>
</ul>

    </article>
</body>
</html>